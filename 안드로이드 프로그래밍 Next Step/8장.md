# 브로드캐스트 리시버

브로드캐스트 리시버는 옵저버(observer) 패턴을 안드로이드에서 구현한 방식이다.

옵저버 패턴에서는 일대다 관계에서 직접 호출하지 않고, 인터페이스를 통한 느슨한 결합을 통해 옵저버를 `register/unregister`하는 방법을 제공한다. 이 방식은 `BroadcastReceiver`에서도 마찬가지이다. `BroadcastReceiver`는 바로 옵저버이고, 이벤트는 `sendBroadcast()`에 전달되는 `intent`이다.

## 8.1 브로드캐스트 리시버 구현
`BroadcastReceiver`에는 추상 메서드가 `onReceive()` 하나뿐

```
abstract void onReceive(Context context, Intent intent);
```

* `onReceive()` 이외에는 대부분이 `final` 메서드이고 오버라이드가 허용되지 않는다. `final` 메서드들은 `onReceive()`에서 호출하는 메서드라고 보면 된다.

`Context`는 전달되므로 이것으로 `startService()`, `startActivity()` 외에 `sendBroadcast()`를 다시 호출할 수도 있다.

### 브로드캐스트 발생 시 브로드캐스트 리시버를 거쳐서 서비스나 액티비티 시작
특정 이벤트가 발생할 때(에를 들어, 부팅이 완료되거나 언어 설정이 변경되는 경우) `startActivity()`나 `startService()`를 직접 실행하는 방법은 없다. `sendBroadcast()`를 통해서 브로드캐스트가 전달되고, 이때 화면을 띄우려면 `BroadcastReceiver`의 `onReceive()` 메서드에서 `startActivity()`를 실행한다. UI가 없는 내부 작업이 필요하다면 `startService()`를 실행한다.

`onReceive()`에서 `startService()`와 `startActivity()`를 둘 다 실행하는 경우도 있다.

### onReceive() 메서드는 메인 스레드에서 실행
`onReceive()` 메서드는 메인 스레드에서 실행되므로 시간 제한이 있다. 10초(포그라운드)/1분(백그라운드: 기본) 네에 `onReceive()` 메서드는 실행을 마쳐야 한다. 10초/1분이 넘으면 ANR이 발생한다. 메인 스레드에서 실행되므로 ANR 타임아웃인 1분/10초/5초도 아닌 훨씬 짧은 시간 내에 처리가 완료되어야 한다. 그렇지 않으면 UI에서 이벤트 처리가 늦어지는 원인이 될 수 있다.

하나의 앱에서 단일 이벤트에 여러 브로드캐스트 리시버가 등록되어 있다면 여러 브로드캐스트 리시버의 `onReceive()` 메서드가 순차적으로 하나씩 실행된다. 이 때문에 브로드캐스트 리시버를 실행하느라 UI 동작에 문제가 생길 수 있다.

### onReceive()에서 Toast 띄우기는 문제가 있음
`Toast`는 비동기 동작. 앱이 포그라운드 프로세스라면 Toast는 정상적으로 잘 동작한다. 하지만 백그라운드 프로세스이거나 앱에서 실행 중인 컴포넌트가 브로드캐스트 리시버밖에 없다면, `onReceive()` 메서드가 끝나자마자 프로세스 우선순위에 밀려서 프로스세가 종료될 수 있다. 이때는 `Toast`가 뜨지 못한다. '동작할 수도 있고 아닐 수도 있다'.

### onReceive()에서 registerReceiver()나 bindService() 메서드 호출이 안 됨
`onReceive()` 메서드에 `Context`가 전달되지만, `Context`의 메서드인 `registerReceiver()`나 `bindService()`를 호출하면 런타임 예외를 발생시킨다.

`onReceive()`에 전달된 `Context`는 구체적으로 `ContextWrapper`인 `Application`을 다시 감싼 `ReceiverRestrictedContext` 인스턴스이다. `ReceiverRestrictedContext`는 `ContextImpl`의 내부 클래스이면서 `ContextImpl`의 내부 클래스이면서 `ContextWrapper`를 상속하고 `registerReceiver()`와 `bindService()`를 오버라이드해서 예외를 발생하게 한 것이다.

* 서비스가 이미 실행 중이라면 브로드캐스트 리시버에서 `bindService()`가 아닌 `peekService()` 메서드를 호출한다. 그리고 서비스에 접근해서 서비스의 메서드를 실행할 수 있다.

## 8.2 브로드캐스트 리시버 등록
브로드캐스트 리시버를 등록하는 방식은 정적인 등록(statically publish)과 동적인 등록(dynamically register) 2가지가 있다. 정적인 등록은 공개의 의미가 있다고 이해하자. 정적으로 등록된 브로드캐스트 리시버는 앱을 설치하자마자 사용이 가능하다.

### 8.2.1 브로드캐스트 리시버 정적 등록
정적인 등록은 `AndroidManifest.xml`에 브로드캐스트 리시버를 추가하는 것이다. 정적으로 등록된 리시버는 브로드캐스트가 발생하면 항상 반응한다. 주로 시스템 이벤트를 받을 때 많이 사용하는 것으로 앱이 실행 중이지 않더라도 프로세스가 뜨고서 이벤트를 처리한다.

* 외부 프로세스의 이벤트를 받는 브로드캐스트 리시버를 만들 때가 많기 때문에 `intent-filter`를 추가해서 암시적 인텐트를 전달받는다. 하지만 로컬 프로세스에서만 사용하는 경우에는 `intent-filter`를 넣지 않고 명시적 인텐트를 전달 받을 수도 있다.

#### Intent 클래스에 정의된 브로드캐스트 액션
`Intent` API 문서 'Broadcast Action:'

[List of all Broadcast Intent actions. API 17](https://github.com/ViliusKraujutis/AndroidBroadcastsMonitor/wiki/List-of-all-Broadcast-Intent-actions.-API-17)

#### 시스템 이벤트는 앱에서 발생시킬 수 없음
"This is a protected intent that can only be sent by the system.". 해당 인텐트는 시스템에서만 발생시킬 수 있고 앱에서 발생시킬 수 없다. 이런 시스템 인텐트를 브로드캐스트하면 `Security Exception`을 만나게 된다.

##### 자주 쓰이는 시스템 이벤트
캘린더 앱의 경우 처리해야 하는 이벤트로는 `ACTION_TIMEZONE_CHANGED`, `ACTION_LOCALE_CHANGED` 액션이 있다.

##### 시스템 이벤트가 아닌 것도 정의되어 있음
`Intent` 클래스에 정의된 브로드캐스트 액션이 모두 시스템 이벤트인 것은 아니다. `ACTION_MEDIA_SCANNER_SCAN_FILE` 액션 같은 것은 앱에서 발생시키라고 있는 것이다. 이미지를 SD 카드에 저장했는데 미디어 스캐닝이 안 돼서 곧바로 화면에 가져올 수 없는 경우가 있다. 이때 앱에서 사용하는 방식이 `ACTION_MEDIA_SCANNER_SCAN_FILE` 액션을 브로드캐스트해서 미디어 스캐너가 동작하게 하는 것이다.
