# 브로드캐스트 리시버

브로드캐스트 리시버는 옵저버(observer) 패턴을 안드로이드에서 구현한 방식이다.

옵저버 패턴에서는 일대다 관계에서 직접 호출하지 않고, 인터페이스를 통한 느슨한 결합을 통해 옵저버를 `register/unregister`하는 방법을 제공한다. 이 방식은 `BroadcastReceiver`에서도 마찬가지이다. `BroadcastReceiver`는 바로 옵저버이고, 이벤트는 `sendBroadcast()`에 전달되는 `intent`이다.

## 8.1 브로드캐스트 리시버 구현
`BroadcastReceiver`에는 추상 메서드가 `onReceive()` 하나뿐

```
abstract void onReceive(Context context, Intent intent);
```

* `onReceive()` 이외에는 대부분이 `final` 메서드이고 오버라이드가 허용되지 않는다. `final` 메서드들은 `onReceive()`에서 호출하는 메서드라고 보면 된다.

`Context`는 전달되므로 이것으로 `startService()`, `startActivity()` 외에 `sendBroadcast()`를 다시 호출할 수도 있다.

### 브로드캐스트 발생 시 브로드캐스트 리시버를 거쳐서 서비스나 액티비티 시작
특정 이벤트가 발생할 때(에를 들어, 부팅이 완료되거나 언어 설정이 변경되는 경우) `startActivity()`나 `startService()`를 직접 실행하는 방법은 없다. `sendBroadcast()`를 통해서 브로드캐스트가 전달되고, 이때 화면을 띄우려면 `BroadcastReceiver`의 `onReceive()` 메서드에서 `startActivity()`를 실행한다. UI가 없는 내부 작업이 필요하다면 `startService()`를 실행한다.

`onReceive()`에서 `startService()`와 `startActivity()`를 둘 다 실행하는 경우도 있다.

### onReceive() 메서드는 메인 스레드에서 실행
`onReceive()` 메서드는 메인 스레드에서 실행되므로 시간 제한이 있다. 10초(포그라운드)/1분(백그라운드: 기본) 네에 `onReceive()` 메서드는 실행을 마쳐야 한다. 10초/1분이 넘으면 ANR이 발생한다. 메인 스레드에서 실행되므로 ANR 타임아웃인 1분/10초/5초도 아닌 훨씬 짧은 시간 내에 처리가 완료되어야 한다. 그렇지 않으면 UI에서 이벤트 처리가 늦어지는 원인이 될 수 있다.

하나의 앱에서 단일 이벤트에 여러 브로드캐스트 리시버가 등록되어 있다면 여러 브로드캐스트 리시버의 `onReceive()` 메서드가 순차적으로 하나씩 실행된다. 이 때문에 브로드캐스트 리시버를 실행하느라 UI 동작에 문제가 생길 수 있다.

### onReceive()에서 Toast 띄우기는 문제가 있음
`Toast`는 비동기 동작. 앱이 포그라운드 프로세스라면 Toast는 정상적으로 잘 동작한다. 하지만 백그라운드 프로세스이거나 앱에서 실행 중인 컴포넌트가 브로드캐스트 리시버밖에 없다면, `onReceive()` 메서드가 끝나자마자 프로세스 우선순위에 밀려서 프로스세가 종료될 수 있다. 이때는 `Toast`가 뜨지 못한다. '동작할 수도 있고 아닐 수도 있다'.

### onReceive()에서 registerReceiver()나 bindService() 메서드 호출이 안 됨
`onReceive()` 메서드에 `Context`가 전달되지만, `Context`의 메서드인 `registerReceiver()`나 `bindService()`를 호출하면 런타임 예외를 발생시킨다.

`onReceive()`에 전달된 `Context`는 구체적으로 `ContextWrapper`인 `Application`을 다시 감싼 `ReceiverRestrictedContext` 인스턴스이다. `ReceiverRestrictedContext`는 `ContextImpl`의 내부 클래스이면서 `ContextImpl`의 내부 클래스이면서 `ContextWrapper`를 상속하고 `registerReceiver()`와 `bindService()`를 오버라이드해서 예외를 발생하게 한 것이다.

* 서비스가 이미 실행 중이라면 브로드캐스트 리시버에서 `bindService()`가 아닌 `` 메서드를 호출한다. 그리고 서비스에 접근해서 서비스의 메서드를 실행할 수 있다.
